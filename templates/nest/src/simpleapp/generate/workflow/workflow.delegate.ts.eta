import {
  Injectable,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import {
  IExecution,
  Item,
  NODE_ACTION,
  FLOW_ACTION,
  IAppDelegate,
  IDefinition,
  BPMNServer,
  Execution,
} from 'bpmn-server';
import { moddleOptions } from 'bpmn-server/dist/elements/js-bpmn-moddle';
let mydelegate: WorkflowDelegate;
@Injectable()
export class WorkflowDelegate implements IAppDelegate {
  protected logger = new Logger();
  server: BPMNServer;
  servicesProvider: any = () => new Object();
  constructor() {}
  getServicesProvider = (execution: Execution) => this.servicesProvider;

  //config will use setServer to define bpmnserver
  setServer(server: BPMNServer) {
    mydelegate = this;
    this.server = server;
    return mydelegate;
  }

  async startUp(options) {
    //  mydelegate.startUp(options);
    // if (options['cron'] == false) {
    // 	return;
    // }
    //     console.log('myserver started');
    //     var query = { "items.status": "start" };
    //     var list = await this.server.dataStore.findItems(query);
    //     if (list.length > 0) {
    //         this.server.logger.log("** There are " + list.length," items that seems to be hung");
    //     }
  }
  sendEmail(to, msg, body) {
    throw Error('sendEmail must be implemented by AppDelegate');
  }

  get moddleOptions() {
    return moddleOptions;
  }
  async executionStarted(execution: IExecution) {}
  async executionEvent(context, event) {}

  async messageThrown(messageId, data, messageMatchingKey: any, item: Item) {
    const msgId = item.node.messageId;
    item.context.logger.log('Message Issued' + msgId);
    // issue it back for others to receive
    const resp = await item.context.engine.throwMessage(
      msgId,
      data,
      messageMatchingKey,
    );
    if (resp && resp.instance) {
      item.context.logger.log(
        ' invoked another process ' +
          resp.instance.id +
          ' for ' +
          resp.instance.name,
      );
    } else await this.issueMessage(messageId, data);
  }

  async issueMessage(messageId, data) {}
  async issueSignal(signalId, data) {}
  async signalThrown(signalId, data, messageMatchingKey: any, item: Item) {
    item.context.logger.log('Signal Issued' + signalId);

    const resp = await item.context.engine.throwSignal(
      signalId,
      data,
      messageMatchingKey,
    );
    if (resp && resp.instance) {
      item.context.logger.log(
        ' invoked another process ' +
          resp.instance.id +
          ' for ' +
          resp.instance.name,
      );
    } else await this.issueSignal(signalId, data);
  }

  consoleKeyTypes = (obj1) => {
    const keys = Object.getOwnPropertyNames(obj1);
    console.log('consoleKeyTypesconsoleKeyTypesconsoleKeyTypes', keys);
    for (let k = 0; k < keys.length; k++) {
      const key = keys[k];

      if (!obj1[key]) {
        console.log(key, 'empty ');
      } else if (typeof obj1[key] == 'object') {
        console.log(key, typeof obj1[key], Object.keys(obj1[key]));
      } else {
        console.log(key, typeof obj1[key], obj1[key]);
      }
    }
  };
  async serviceCalled(inputdata, item: Item) {
    // try{
    //server
    //uids
    //instance
    //definition
    //process  =>[ '$type', 'id', 'isExecutable', 'flowElements' ]
    //Item => cant get
    //state
    // this.logger.error('EXECUTING serviceCalled');
    //   const delegateServiceName = item['item']['element']['def']['delegateExpression']
    //   this.logger.error("EXECUTING serviceCalled",delegateServiceName)
    //   const processName = item['instance']['name'];
    //   const data = item['instance']['data'];
    //   const vars = item['instance']['vars'];
    //   const props = {
    //     processName: processName,
    //     delegateName: delegateServiceName,
    //     inputData: inputdata,
    //     vars: vars,
    //     data: data,
    //   };
    // if (
    //   this.servicesProvider[processName] &&
    //   this.servicesProvider[processName][delegateServiceName]
    // ) {
    //   this.servicesProvider[processName][delegateServiceName](props, item);
    // } else {
    //   this.logger.error(
    //     `Undefined delegate service "${processName}":"${delegateServiceName}"`,
    //     props,
    //   );
    // }
    // }catch(e){
    //   this.logger.error(
    //     `Unknown error delegate service `,
    //     Object.keys(item)
    //   );
    // }
  }

  scopeEval(scope, script) {
    let result;

    try {
      var js = `
            var item=this;
            var data=this.data;
            var input=this.input;
            var output=this.output;
            return (${script});`;
      result = Function(js).bind(scope)();
    } catch (exc) {
      console.log('error in script evaluation', js);
      console.log(exc);
    }
    return result;
  }
  async scopeJS(scope, script) {
    const AsyncFunction = Object.getPrototypeOf(
      async function () {},
    ).constructor;
    let result;
    try {
      var js = `
            var item=this;
            var data=this.data;
            var input=this.input;
            var output=this.output;
            ${script}`;
      result = await new AsyncFunction(js).bind(scope)();
      scope.token.log('..executing js is done ' + scope.id);
    } catch (exc) {
      scope.token.log(
        'ERROR in executing Script ' + exc.message + '\n' + script,
      );
      console.log('error in script execution', js);
      console.log(exc);
    }
    return result;
  }
}
