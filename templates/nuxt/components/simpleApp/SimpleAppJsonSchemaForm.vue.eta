<template>
    <form class="simpleapp-form" @submit.prevent="true">
        <slot name="header"><h3 class="flex flex-col">{{ title }}</h3></slot>
        <slot  name="default" :getField="getField" :validate="validate"></slot>
    </form>
</template>
<script setup lang="ts" >
import type { JSONSchema7,JSONSchema7Definition } from 'json-schema';
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import addErrors from 'ajv-errors';
import _ from 'lodash'

    const props = defineProps<{
        title?:string,
        schema:JSONSchema7,
        data:any,
        // document: SimpleAppClient<any,any>
        readonly?:boolean
    }>()
    if(!props.schema){
        throw "undefine jsonschema property 'schema'"
    }
    const formerrors = ref<any>({})
    const getField = (path:string)=>{
    const schema = props.schema
    const fieldsetting = getPathObject(schema,path)
    
    return {
            path: path,
            key: _.last(path.split('/')),
            instancepath: getInstancePath(schema,path),
            fieldsetting: fieldsetting,            
            isrequired: getIsRequired(schema,path),
            errors: formerrors,
            readonly: props.readonly
        } //as SimpleAppFieldSetting
    }

    
    const getIsRequired=(schema:any,path:string)=>{
        if(!path){
            console.error('unknown path')
            return 'xx'
        }

        try{
            let paths = path.replace('#/','').split('/')
            const fieldname = paths[paths.length-1]
            paths = paths.slice(0, -2);    
            let tmp = schema
            for(let i=0;i<paths.length;i++){
                tmp = tmp[paths[i]]
                
            }
            if(Array.isArray(tmp['required'])   ) {
                    const arr:string[] = tmp['required']
                    return arr.includes (fieldname)
                }else{
                    return false
                }

            // console.log("get instance path",instancepath)
            
            // return tmp
        }catch(err:any){
            console.error(err.message)
        }
    }
   const getInstancePath=(schema:any,path:string)=>{
    if(!path){
        console.error('unknown path')
        return 'yy'
    }
    try{
        let paths = path.replace('#/','').split('/')    
        let tmp = schema
        let instancepath=''
        for(let i=0;i<paths.length;i++){
            tmp = tmp[paths[i]]
            if(tmp['type'] && paths[i] !='items'){
                instancepath=instancepath+'/'+paths[i]
            }
        }

        // console.log("get instance path",instancepath)
        return instancepath
        // return tmp
    }catch(err:any){
        console.error(err.message)
    }


    // let paths = path.replace('#/','').split('/')    
    // return '/'+paths[1]
   }
   const getPathObject=(schema:JSONSchema7,path:string):JSONSchema7|undefined=>{
    // console.log("path",path)
    if(!path){
        console.error('unknown path')
        return undefined
    }
    try{
        let paths:string[] = path.replace('#/','').split('/')    
        let tmp :JSONSchema7Definition= schema
        // console.log(path)
        for(let i=0;i<paths.length;i++){
            
            //silly code, but it seems require to avoid typescript complaint.
            //ultimately it is to obtain result as "tmp=tmp[path[i]]"
            const key1 = paths[i] as keyof JSONSchema7
            let jsonkey: keyof JSONSchema7 = key1
            let obj:JSONSchema7 = {} as JSONSchema7
            Object.assign(obj,tmp[jsonkey])
            tmp = {...obj}            
        }
        // console.log('final ',path,tmp)
        return tmp
    }catch(err:any){
        console.error(err.message)
        
    }    
   }


   const validate=(callback:Function) => {
    const ajv = new Ajv({ allErrors: true });
    addFormats(ajv);
    addErrors(ajv)
    
    ajv.addFormat('tel',/^$|^\d{7,15}$/gm)    
    ajv.addFormat('text',/.*$/)
    ajv.addFormat('html',/.*$/)
    ajv.addFormat('documentno',/.*$/)
    
    ajv.addKeyword({ keyword: 'x-foreignkey', schemaType: 'string' });
    ajv.addKeyword({ keyword: 'x-simpleapp-config', schemaType: 'object' });

    
    // this.errorlist.value = {};
    // this.hook('pre-validation', this.data.value);
    const validate = ajv.compile(props.schema);
    console.log("validate data",props.data)
    const valid = validate(props.data);
    if (!valid) {
      const errors = validate.errors;
      const tmp: { [key: string]: any } = {};
      if (errors) {
        for (let i = 0; i < errors?.length; i++) {
          const key: string = errors[i]['instancePath'];
          if (!tmp[key]) {
            tmp[key] = [];
          }
          tmp[key].push(errors[i]);
        }
      }
      formerrors.value = tmp;
      console.error(formerrors.value );

      // return validate.errors;
      callback(formerrors.value )
    } else {
        //   this.hook('post-validation', this.data.value);
        callback(false)
    }
  }

</script>