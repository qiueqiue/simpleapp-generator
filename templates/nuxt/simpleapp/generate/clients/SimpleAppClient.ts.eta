/**
 * This file was automatically generated by simpleapp generator. Every
 * MODIFICATION OVERRIDE BY GENERATEOR
 * last change 2023-10-28
 * Author: Ks Tan
 */
import Ajv from 'ajv';
import addFormats from 'ajv-formats';
import addErrors from 'ajv-errors';
import { ref } from 'vue';
import type { Ref } from 'vue';
import type { AxiosResponse } from 'axios';
import {SearchBody,Notification,NotificationStatus,SchemaType} from '~/types'

// import { useToast, } from 'primevue/usetoast';
// import type {  ToastMessageOptions } from 'primevue/toast';
// const toast = useToast();

type crudType = {
  runFindOne: Function;  
  runCreate: Function;
  runUpdate: Function;  
  runDelete: Function;
  runSearch: Function
};
export class SimpleAppClient<
  TData extends { _id?: string,created:string },
  TApi extends crudType,
> {
  protected defaultTimeOut=5000
  protected docapi;
  public event:Function|null=null;
  public listen:Function|null=null;
  protected data = <Ref<TData>>ref({} as TData);
  public schema = {} as SchemaType; //cant define data type, cause it make autocomplete gone.
  protected doctype = '';
  protected docname = '';
  protected errorlist = ref({});
  protected completeformula = true;
  constructor(apiobj: TApi,doctype:string,docname:string) {
    this.docapi = apiobj;
    this.doctype=doctype
    this.docname = docname
  }

  getDocType = () => this.doctype;
  getDocName = () => this.docname;
  setNew = ()=>{}
  isNew = () => this.data.value['created']==''
  setSchema = (schema: SchemaType) => (this.schema = schema);
  getSchema = ():SchemaType=> this.schema;
  getErrors = () => this.errorlist;
  getData = () => this.data.value;
  getApi = () =>this.docapi;
  getReactiveData = () => this.data;
  public reCalculateValue (){}
  setData = (data: any) => {
    // this.data.value = data;
    Object.assign(this.data.value, data);
  };
  
  async getById(id: string) {
    return await this.docapi.runFindOne(id,{timeout:this.defaultTimeOut})
    .then((res: AxiosResponse) => {
      // if(this.event){this.event('info:getById',res.data)}
      Object.assign(this.data.value, res.data);
      return res;
    }).catch((res:any)=>{
      // if(this.event){this.event('error:getById',res)}
      return Promise.reject(res)
    });
  }

  async create() {
    const errors = this.validateFailed();
    const {$event} =useNuxtApp()
    if (errors) {
      $event('Notification',{
        documentName:this.getDocName(),
        summary:'Record create failed',
        status:NotificationStatus.error,
        data:errors
      })
      // this.event('error:create',errors)
      return await Promise.reject(errors);
    } else {
      return await this.docapi
        .runCreate(this.data.value,{timeout:this.defaultTimeOut})
        .then((res: AxiosResponse) => {
          // if(this.event){this.event('success:create',res.data);return res.data}
          // console.log(this.getDocName(), "ok")
          $event('Notification',{
            documentName:this.getDocName(),
            summary:'Record create successfully',
            status:NotificationStatus.success
          })
          this.data.value = { ...res.data };
          return res;
        }).catch((errors:any)=>{   
          // console.log(this.getDocName(),"-----failed")
            $event('Notification',{
              documentName:this.getDocName(),
              summary:'Record create failed',
              status:NotificationStatus.error,
              data:errors.response.data.data
            })
            console.error('error:create',errors.response.data.data)
          return Promise.reject(errors)
        });
    }
  }

  async update() {
    const {$event} =useNuxtApp()
    const recordid: string = this.data.value._id ?? '';
    const errors = this.validateFailed();
    if (errors) {
      // if(this.event){this.event('error:update',errors)}
      $event('Notification',{
        documentName:this.getDocName(),
        summary:'Record update failed',
        status:NotificationStatus.error,
        data:errors
      })
      console.error('update errors',errors)
      return await Promise.reject(errors);
    } else {
      return await this.docapi
        .runUpdate(recordid, this.data.value,{timeout:this.defaultTimeOut})
        .then((res: AxiosResponse) => {
          // if(this.event){this.event('success:update',res.data)}
          $event('Notification',{
            documentName:this.getDocName(),
            summary:'Record update success',
            status:NotificationStatus.success,
            data:errors
          })
          return res.data;
        }).catch((errors:any)=>{
          $event('Notification',{
            documentName:this.getDocName(),
            summary:'Record update failed',
            status:NotificationStatus.error,
            data:errors.response.data.data
          })
          // console.error('error:update---',errors,",---",errors.message)
          // if(this.event){
          // this.event('error:update',errors.response.data.data)}
          console.error('error:update',errors.response.data.data)
          return Promise.reject(errors)
        });
    }
  }
  async delete(id: string) {
    const {$event} =useNuxtApp()
    return await this.docapi.runDelete(id,{timeout:this.defaultTimeOut})
      .then((res:AxiosResponse)=>{
        // if(this.event){this.event('success:delete',res.data)}
        $event('Notification',{
          documentName:this.getDocName(),
          summary:'Record deleted successfully',
          status:NotificationStatus.success,
          data:res.data
        })
        return Promise.resolve(res.data)
      }).catch((errors:any)=>{
        // if(this.event){this.event('error:delete',errors.response.data.data)}
        $event('Notification',{
          documentName:this.getDocName(),
          summary:'Record delete failed',
          status:NotificationStatus.error,
          data:errors.response.data.data
        })
        console.error(errors.response.data.data)
        return Promise.reject(errors)
      });
  }
  async search(searchbody:SearchBody) {
    return await this.docapi.runSearch(searchbody,{timeout:this.defaultTimeOut})
        .then((res:AxiosResponse)=>{
          // if(this.event){this.event('info:listready',res.data);}
          return res.data
        }).catch((errors:any)=>{
          // if(this.event){this.event('error:list',errors.response.data.data)}
          return Promise.reject(errors)
        });
  }
  
  hook(type: string, data: TData) {
    //console.log('internal save hook');
    return true;
  }
  validateFailed() {
    const ajv = new Ajv({ allErrors: true });
    addFormats(ajv);
    addErrors(ajv)
    
    ajv.addFormat('tel',/^$|^\d{7,15}$/gm)    
    ajv.addFormat('text',/.*$/)
    ajv.addFormat('html',/.*$/)
    ajv.addFormat('documentno',/.*$/)
    
    ajv.addKeyword({ keyword: 'x-foreignkey', schemaType: 'string' });
    ajv.addKeyword({ keyword: 'x-simpleapp-config', schemaType: 'object' });

    
    this.errorlist.value = {};
    this.hook('pre-validation', this.data.value);
    const validate = ajv.compile(this.schema);
    const valid = validate(this.data.value);
    if (!valid) {
      const errors = validate.errors;
      const tmp: { [key: string]: any } = {};
      if (errors) {
        for (let i = 0; i < errors?.length; i++) {
          const key: string = errors[i]['instancePath'];
          if (!tmp[key]) {
            tmp[key] = [];
          }
          tmp[key].push(errors[i]);
        }
      }
      // console.error(tmp);
      this.errorlist.value = tmp;
      // console.error(this.errorlist);

      // return validate.errors;
      return ajv.errors??validate.errors;
    } else {
      this.hook('post-validation', this.data.value);
      return false;
    }
  }

}
